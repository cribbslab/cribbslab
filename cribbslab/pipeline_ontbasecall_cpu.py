"""===========================
Pipeline ont_basecall_cpu
===========================


Overview
========

This pipeline was written to parse input fast5 files and then basecall using guppy. If you dont split the files then the basecalling takes many many hours, espacially when the high accuracy setting is used.


Usage
=====

See :ref:`PipelineSettingUp` and :ref:`PipelineRunning` on general
information how to use CGAT pipelines.

Configuration
-------------

The pipeline requires a configured :file:`pipeline.yml` file.
CGATReport report requires a :file:`conf.py` and optionally a
:file:`cgatreport.ini` file (see :ref:`PipelineReporting`).

Default configuration files can be generated by executing:

   python <srcdir>/pipeline_ont_basecall_cpu.py config

Input files
-----------

None required except the pipeline configuration files.

Requirements
------------

The path to the basecaller guppy added to the config file.


Pipeline output
===============

The output of the pipeline is a series of fastq files.


Code
====

"""
import sys
import os
from ruffus import *
import cgatcore.pipeline as P
import cgatcore.experiment as E

# load options from the config file
PARAMS = P.get_parameters(
    ["%s/pipeline.yml" % os.path.splitext(__file__)[0],
     "../pipeline.yml",
     "pipeline.yml"])


INPUT_FORMATS = ["%s/*.fast5" % PARAMS['fast5_dir']]


@transform(INPUT_FORMATS,
           regex(".*/(\S+).fast5"),
           r"tmp_fast5/\1/\1.fast5")
def split_fast5(infile, outfile):
    '''Pick up each fast5 and then split into respective directories '''

    outf = os.path.basename(infile)
    path = os.path.dirname(outfile)

    statement = '''ln -s %(infile)s %(outfile)s'''

    P.run(statement)


@transform(split_fast5,
         regex("tmp_fast5/(\S+).fast5"),
         r"%s/\1.fastq" % PARAMS['outfile'])
def basecall(infile, outfile):
    '''basecall using guppy.'''

    inf_dir = os.path.dirname(infile)
    out_dir = os.path.dirname(outfile)


    statement = '''%(ontsoftware)s -i %(inf_dir)s -s %(out_dir)s -c %(config)s --cpu_threads_per_caller 10 --num_callers 1'''

    P.run(statement,
          job_threads=10)


@follows(basecall)
def full():
    pass

def main(argv=None):
    if argv is None:
        argv = sys.argv
    P.main(argv)


if __name__ == "__main__":
    sys.exit(P.main(sys.argv))    
